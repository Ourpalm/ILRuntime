<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Reflection.Metadata</name>
    </assembly>
    <members>
        <member name="M:System.Reflection.BlobWriter.ContentEquals(System.Reflection.BlobWriter)">
            <summary>
            Compares the current content of this writer with another one.
            </summary>
        </member>
        <member name="M:System.Reflection.BlobWriter.ToArray(System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the buffer content.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the buffer content.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Byte,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Reflection.BlobBuilder)">
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the <paramref name="buffer"/>.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Byte[])">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the <paramref name="buffer"/>.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteReference(System.UInt32,System.Int32)">
            <summary>
            Writes a reference to a heap (heap index) or a table (row id).
            </summary>
            <remarks>
            References may be small (2B) or large (4B).
            </remarks>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteUTF16(System.Char[])">
            <summary>
            Writes UTF16 (little-endian) encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteUTF16(System.String)">
            <summary>
            Writes UTF16 (little-endian) encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteSerializedString(System.String)">
            <summary>
            Writes string in SerString format (see ECMA-335-II 23.3 Custom attributes): 
            The string is UTF8 encoded and prefixed by the its size in bytes. 
            Null string is represented as a single byte 0xFF.
            </summary>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteUTF8(System.String,System.Boolean)">
            <summary>
            Writes UTF8 encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
            <summary>
            Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
            </summary>
            <remarks>
            If the value lies between -64 (0xFFFFFFC0) and 63 (0x3F), inclusive, encode as a one-byte integer: 
            bit 7 clear, value bits 5 through 0 held in bits 6 through 1, sign bit (value bit 31) in bit 0.
            
            If the value lies between -8192 (0xFFFFE000) and 8191 (0x1FFF), inclusive, encode as a two-byte integer: 
            15 set, bit 14 clear, value bits 12 through 0 held in bits 13 through 1, sign bit(value bit 31) in bit 0.
            
            If the value lies between -268435456 (0xF000000) and 268435455 (0x0FFFFFFF), inclusive, encode as a four-byte integer: 
            31 set, 30 set, bit 29 clear, value bits 27 through 0 held in bits 28 through 1, sign bit(value bit 31) in bit 0.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> can't be represented as a compressed signed integer.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteCompressedInteger(System.Int32)">
            <summary>
            Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
            </summary>
            <remarks>
            If the value lies between 0 (0x00) and 127 (0x7F), inclusive, 
            encode as a one-byte integer (bit 7 is clear, value held in bits 6 through 0).
            
            If the value lies between 28 (0x80) and 214 â€“ 1 (0x3FFF), inclusive, 
            encode as a 2-byte integer with bit 15 set, bit 14 clear(value held in bits 13 through 0).
            
            Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 clear (value held in bits 28 through 0).
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> can't be represented as a compressed signed integer.</exception>
        </member>
        <member name="M:System.Reflection.BlobWriter.WriteConstant(System.Object)">
            <summary>
            Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is not of a constant type.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.GetBlobs">
            <summary>
            Returns a sequence of all blobs that represent the content of the builder.
            </summary>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ContentEquals(System.Reflection.BlobBuilder)">
            <summary>
            Compares the current content of this writer with another one.
            </summary>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ToArray">
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ToArray(System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the buffer content.</exception>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ToImmutableArray">
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the buffer content.</exception>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteContentTo(System.IO.Stream)">
            <exception cref="T:System.ArgumentNullException"><paramref name="destination"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteContentTo(System.Reflection.BlobWriter@)">
            <exception cref="T:System.ArgumentNullException"><paramref name="destination"/> is default(<see cref="T:System.Reflection.BlobWriter"/>).</exception>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteContentTo(System.Reflection.BlobBuilder)">
            <exception cref="T:System.ArgumentNullException"><paramref name="destination"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.LinkPrefix(System.Reflection.BlobBuilder)">
            <exception cref="T:System.ArgumentNullException"><paramref name="prefix"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.LinkSuffix(System.Reflection.BlobBuilder)">
            <exception cref="T:System.ArgumentNullException"><paramref name="suffix"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.ReserveBytes(System.Int32)">
            <summary>
            Reserves a contiguous block of bytes.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/> is negative.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
            <returns>Bytes successfully written from the <paramref name="source" />.</returns>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the <paramref name="buffer"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Byte[])">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start"/> and <paramref name="byteCount"/> falls outside of the bounds of the <paramref name="buffer"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.PadTo(System.Int32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.Align(System.Int32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteBoolean(System.Boolean)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteByte(System.Byte)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteSByte(System.SByte)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteDouble(System.Double)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteSingle(System.Single)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteInt16(System.Int16)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUInt16(System.UInt16)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteInt16BE(System.Int16)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUInt16BE(System.UInt16)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteInt32BE(System.Int32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUInt32BE(System.UInt32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteInt32(System.Int32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUInt32(System.UInt32)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteInt64(System.Int64)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUInt64(System.UInt64)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteDecimal(System.Decimal)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteDateTime(System.DateTime)">
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteReference(System.UInt32,System.Int32)">
            <summary>
            Writes a reference to a heap (heap index) or a table (row id).
            </summary>
            <remarks>
            References may be small (2B) or large (4B).
            </remarks>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUTF16(System.Char[])">
            <summary>
            Writes UTF16 (little-endian) encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUTF16(System.String)">
            <summary>
            Writes UTF16 (little-endian) encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteSerializedString(System.String)">
            <summary>
            Writes string in SerString format (see ECMA-335-II 23.3 Custom attributes): 
            The string is UTF8 encoded and prefixed by the its size in bytes. 
            Null string is represented as a single byte 0xFF.
            </summary>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
            <summary>
            Writes UTF8 encoded string at the current position.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
            <summary>
            Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
            </summary>
            <remarks>
            If the value lies between -64 (0xFFFFFFC0) and 63 (0x3F), inclusive, encode as a one-byte integer: 
            bit 7 clear, value bits 5 through 0 held in bits 6 through 1, sign bit (value bit 31) in bit 0.
            
            If the value lies between -8192 (0xFFFFE000) and 8191 (0x1FFF), inclusive, encode as a two-byte integer: 
            15 set, bit 14 clear, value bits 12 through 0 held in bits 13 through 1, sign bit(value bit 31) in bit 0.
            
            If the value lies between -268435456 (0xF000000) and 268435455 (0x0FFFFFFF), inclusive, encode as a four-byte integer: 
            31 set, 30 set, bit 29 clear, value bits 27 through 0 held in bits 28 through 1, sign bit(value bit 31) in bit 0.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> can't be represented as a compressed signed integer.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteCompressedInteger(System.Int32)">
            <summary>
            Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
            </summary>
            <remarks>
            If the value lies between 0 (0x00) and 127 (0x7F), inclusive, 
            encode as a one-byte integer (bit 7 is clear, value held in bits 6 through 0).
            
            If the value lies between 28 (0x80) and 214 â€“ 1 (0x3FFF), inclusive, 
            encode as a 2-byte integer with bit 15 set, bit 14 clear (value held in bits 13 through 0).
            
            Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 clear (value held in bits 28 through 0).
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value"/> can't be represented as a compressed integer.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="M:System.Reflection.BlobBuilder.WriteConstant(System.Object)">
            <summary>
            Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> is not of a constant type.</exception>
            <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
        </member>
        <member name="T:System.Reflection.Internal.AbstractMemoryBlock">
            <summary>
            Represents a disposable blob of memory accessed via unsafe pointer.
            </summary>
        </member>
        <member name="P:System.Reflection.Internal.AbstractMemoryBlock.Pointer">
            <summary>
            Pointer to the underlying data (not valid after disposal).
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.AbstractMemoryBlock.GetContent(System.Int32)">
            <summary>
            Returns the content of the memory block. 
            </summary>
            <remarks>
            Only creates a copy of the data if they are not represented by a managed byte array, or the offset is non-zero.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.AbstractMemoryBlock.Dispose">
            <summary>
            Disposes the block. 
            </summary>
            <remarks>
            The operation is idempotent, but must not be called concurrently with any other operations on the block
            or with another call to Dispose.
            
            Using the block after dispose is an error in our code and therefore no effort is made to throw a tidy 
            ObjectDisposedException and null ref or AV is possible.
            </remarks>
        </member>
        <member name="T:System.Reflection.Internal.ByteArrayMemoryBlock">
            <summary>
            Represents a memory block backed by an array of bytes.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ExternalMemoryBlock">
            <summary>
            Class representing raw memory but not owning the memory.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ExternalMemoryBlockProvider">
            <summary>
            Represents raw memory owned by an external object. 
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetMemoryBlock">
            <summary>
            Creates and hydrates a memory block representing all data.
            </summary>
            <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetMemoryBlock(System.Int32,System.Int32)">
            <summary>
            Creates and hydrates a memory block representing data in the specified range.
            </summary>
            <param name="start">Starting offset relative to the beginning of the data represented by this provider.</param>
            <param name="size">Size of the resulting block.</param>
            <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetStream(System.Reflection.Internal.StreamConstraints@)">
            <summary>
            Gets a seekable and readable <see cref="T:System.IO.Stream"/> that can be used to read all data.
            The operations on the stream has to be done under a lock of <see cref="F:System.Reflection.Internal.StreamConstraints.GuardOpt"/> if non-null.
            The image starts at <see cref="F:System.Reflection.Internal.StreamConstraints.ImageStart"/> and has size <see cref="F:System.Reflection.Internal.StreamConstraints.ImageSize"/>.
            It is the caller's responsibility not to read outside those bounds.
            </summary>
        </member>
        <member name="P:System.Reflection.Internal.MemoryBlockProvider.Size">
            <summary>
            The size of the data.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.NativeHeapMemoryBlock">
            <summary>
            Represents memory block allocated on native heap.
            </summary>
            <remarks>
            Owns the native memory resource.
            </remarks>
        </member>
        <member name="T:System.Reflection.Internal.StreamMemoryBlockProvider">
            <summary>
            Represents data read from a stream.
            </summary>
            <remarks>
            Uses memory map to load data from streams backed by files that are bigger than <see cref="F:System.Reflection.Internal.StreamMemoryBlockProvider.MemoryMapThreshold"/>.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.StreamMemoryBlockProvider.GetMemoryBlockImpl(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException">Error while reading from the stream.</exception>
        </member>
        <member name="T:System.Reflection.Internal.EncodingHelper">
             <summary>
             Provides helpers to decode strings from unmanaged memory to System.String while avoiding
             intermediate allocation.
             
             This has three components:
             
               (1) Light-up Encoding.GetString(byte*, int) via reflection and resurface it as extension 
                   method. 
            
                   This is a new API that will provide API convergence across all platforms for 
                   this scenario. It is already on .NET 4.6+ and ASP.NET vNext, but not yet available 
                   on every platform we support. See below for how we fall back.
            
               (2) Deal with WinRT prefixes. 
            
                  When reading managed winmds with projections enabled, the metadata   reader needs to prepend 
                  a WinRT prefix in some case . Doing this without allocation poses a problem
                  as we don't have the prefix and input in contiguous data that we can pass to the
                  Encoding.GetString. We handle this case using pooled managed scratch buffers where we copy
                  the prefix and input and decode using Encoding.GetString(byte[], int, int).
            
               (3) Deal with platforms that don't yet have Encoding.GetString(byte*, int). 
               
                  If we're running on a full framework earlier than 4.6, we will bind to the internal
                  String.CreateStringFromEncoding which is equivalent and Encoding.GetString is just a trivial 
                  wrapper around it in .NET 4.6. This means that we always have the fast path on every
                  full framework version we support.
            
                  If we can't bind to it via reflection, then we emulate it using what is effectively (2) and 
                  with an empty prefix. 
            
             For both (2) and (3), the pooled buffers have a fixed size deemed large enough for the
             vast majority of metadata strings. In the rare worst case (byteCount > threshold and
             (lightUpAttemptFailed || prefix != null), we give up and allocate a temporary array,
             copy to it, decode, and throw it away.
             </summary>
        </member>
        <member name="F:System.Reflection.Internal.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:System.Reflection.Internal.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:System.Reflection.Internal.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="T:System.Reflection.Internal.ImmutableByteArrayInterop">
             <summary>
             Provides tools for using <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> in interop scenarios.
             </summary>
             <remarks>
             *** WARNING *** 
             
             If you decide to copy this code elsewhere, please retain the documentation here
             and the Dangerous prefixes in the API names. This will help track down and audit
             other places where this technique (with dangerous consequences when misused) may
             be applied.
            
             A generic version of this API was once public in a pre-release of immutable 
             collections, but  it was deemed to be too subject to abuse when available publicly.
             
             This implementation is scoped to byte arrays as that is all that the metadata reader needs.
             
             Also, since we don't have access to immutable collection internals, we use a trick involving
             overlapping a <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with a <see cref="T:Byte[]"/> refer. While
             unverifiable, it is valid. See Ecma 335, section II.10.7 Controlling instance layout:
             
             "It is possible to overlap fields in this way, though offsets occupied by an object reference 
             shall not overlap with offsets occupied by a built-in value type or a part of
             another object reference. While one object reference can completely overlap another, this is
             unverifiable."
             
             Furthermore, the fact that <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> backed by a single <see cref="T:Byte[]"/> 
             field is something inherent to the design of ImmutableArray in order to get its performance
             characteristics and therefore something we (Microsoft) are comfortable defining as a contract that 
             can be depended upon as below.
             </remarks>
        </member>
        <member name="M:System.Reflection.Internal.ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(System.Byte[]@)">
            <summary>
            Creates a new instance of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> using a given mutable array as the backing
            field, without creating a defensive copy. It is the responsibility of the caller to ensure no other mutable 
            references exist to the array.  Do not mutate the array after calling this method.
            </summary>
            <param name="array">The mutable array to use as the backing field. The incoming reference is set to null 
            since it should not be retained by the caller.</param>
            <remarks>
            Users of this method should take extra care to ensure that the mutable array given as a parameter
            is never modified. The returned <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> will use the given array as its backing
            field without creating a defensive copy, so changes made to the given mutable array will be observable
            on the returned <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            and <see cref="T:System.Collections.Immutable.ImmutableArray"/> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> instance
            whose underlying backing field is modified. 
            </remarks>
            <returns>An immutable array.</returns>
        </member>
        <member name="M:System.Reflection.Internal.ImmutableByteArrayInterop.DangerousGetUnderlyingArray(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Access the backing mutable array instance for the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>, without
            creating a defensive copy.  It is the responsibility of the caller to ensure the array is not modified
            through the returned mutable reference.  Do not mutate the returned array.
            </summary>
            <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> from which to retrieve the backing field.</param>
            <remarks>
            Users of this method should take extra care to ensure that the returned mutable array is never modified.
            The returned mutable array continues to be used as the backing field of the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            without creating a defensive copy, so changes made to the returned mutable array will be observable
            on the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            and <see cref="T:System.Collections.Immutable.ImmutableArray"/> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> instance
            whose underlying backing field is modified. 
            </remarks>
            <returns>The underlying array, or null if <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/> is true.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.PeekCompressedInteger(System.Int32,System.Int32@)">
            <summary>
            Decodes a compressed integer value starting at offset. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="offset">Offset to the start of the compressed data.</param>
            <param name="numberOfBytesRead">Bytes actually read.</param>
            <returns>
            Value between 0 and 0x1fffffff, or <see cref="F:System.Reflection.Metadata.BlobReader.InvalidCompressedInteger"/> if the value encoding is invalid.
            </returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.PeekUtf8NullTerminated(System.Int32,System.Byte[],System.Reflection.Metadata.MetadataStringDecoder,System.Int32@,System.Char)">
            <summary>
            Read UTF8 at the given offset up to the given terminator, null terminator, or end-of-block.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="prefix">UTF8 encoded prefix to prepend to the bytes at the offset before decoding.</param>
            <param name="utf8Decoder">The UTF8 decoder to use that allows user to adjust fallback and/or reuse existing strings without allocating a new one.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string. 
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.GetUtf8NullTerminatedLength(System.Int32,System.Int32@,System.Char)">
            <summary>
            Get number of bytes from offset to given terminator, null terminator, or end-of-block (whichever comes first).
            Returned length does not include the terminator, but numberOfBytesRead out parameter does.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string. 
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <returns>Length (byte count) not including terminator.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchForSlot(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)">
            <summary>
            In a table that specifies children via a list field (e.g. TypeDef.FieldList, TypeDef.MethodList), 
            seaches for the parent given a reference to a child.
            </summary>
            <returns>Returns row number [0..RowCount).</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchReference(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)">
            <summary>
            In a table ordered by a column containing entity references seaches for a row with the specified reference.
            </summary>
            <returns>Returns row number [0..RowCount) or -1 if not found.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchReferenceRange(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchReferenceRange(System.Int32[],System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.StreamExtensions.CopyTo(System.IO.Stream,System.Byte*,System.Int32)">
            <summary>
            Copies specified amount of data from given stream to a target memory pointer.
            </summary>
            <exception cref="T:System.IO.IOException">unexpected stream end.</exception>
        </member>
        <member name="M:System.Reflection.Internal.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.Decoding.CustomAttributeDecoder`1">
            <summary>
            Decodes custom attribute blobs.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ICustomAttributeTypeProvider`1.GetSystemType">
            <summary>
            Gets the TType representation for <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
            <summary>
            Returns true if the given type represents <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
            <summary>
            Get the type symbol for the given serialized type name.
            The serialized type name is in so-called "reflection notation" (i.e. as understood by <see cref="M:System.Type.GetType(System.String)"/>.)
            </summary>
            <exception cref="T:System.BadImageFormatException">The name is malformed.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
            <summary>
            Gets the underlying type of the given enum type symbol.
            </summary>
            <exception cref="T:System.BadImageFormatException">The given type symbol does not represent an enum.</exception>
        </member>
        <member name="T:System.Reflection.Metadata.Decoding.ArrayShape">
            <summary>
            Represents the shape of an array type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.ArrayShape.Rank">
            <summary>
            Gets the number of dimensions in the array.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.ArrayShape.Sizes">
            <summary>
            Gets the sizes of each dimension. Length may be smaller than rank, in which case the trailing dimensions have unspecified sizes.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.ArrayShape.LowerBounds">
            <summary>
            Gets the lower-bounds of each dimension. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
            <summary>
            Gets the type symbol for a single-dimensional array with zero lower bounds of the given element type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISignatureTypeProvider`1.GetFunctionPointerType(System.Reflection.Metadata.Decoding.MethodSignature{`0})">
            <summary>
            Gets the a type symbol for the function pointer type of the given method signature.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISignatureTypeProvider`1.GetGenericMethodParameter(System.Int32)">
            <summary>
            Gets the type symbol for the generic method parameter at the given zero-based index.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISignatureTypeProvider`1.GetGenericTypeParameter(System.Int32)">
            <summary>
            Gets the type symbol for the generic type parameter at the given zero-based index.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISignatureTypeProvider`1.GetModifiedType(System.Reflection.Metadata.MetadataReader,System.Boolean,`0,`0)">
            <summary>
            Gets the type symbol for a type with a custom modifier applied.
            </summary>
            <param name="reader">The metadata reader that was passed to the <see cref="T:System.Reflection.Metadata.Decoding.SignatureDecoder`1"/>. It may be null.</param>
            <param name="isRequired">True if the modifier is required, false if it's optional.</param>
            <param name="modifier">The modifier type applied. </param>
            <param name="unmodifiedType">The type symbol of the underlying type without modifiers applied.</param>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ISignatureTypeProvider`1.GetPinnedType(`0)">
            <summary>
            Gets the type symbol for a local variable type that is marked as pinned.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ITypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.Decoding.SignatureTypeHandleCode)">
            <summary>
            Gets the type symbol for a type definition.
            </summary>
            <param name="reader">
            The metadata reader that was passed to the<see cref= "T:System.Reflection.Metadata.Decoding.SignatureDecoder`1" />. It may be null.
            </param>
            <param name="handle">
            The type definition handle.
            </param>
            <param name="code">
            When <see cref="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes"/> is used indicates whether
            the type reference is to class or value type. Otherwise <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Unresolved"/>
            will be passed.
            </param>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ITypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.Decoding.SignatureTypeHandleCode)">
            <summary>
            Gets the type symbol for a type reference.
            </summary>
            <param name="reader">
            The metadata reader that was passed to the <see cref= "T:System.Reflection.Metadata.Decoding.SignatureDecoder`1" />. It may be null.
            </param>
            <param name="handle">
            The type definition handle.
            </param>
            <param name="code">
            When <see cref="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes"/> is used indicates whether
            the type reference is to class or value type. Otherwise <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Unresolved"/>
            will be passed.
            </param>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.ITypeProvider`1.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.Decoding.SignatureTypeHandleCode)">
            <summary>
            Gets the type symbol for a type specification.
            </summary>
            <param name="reader">
            The metadata reader that was passed to the <see cref= "T:System.Reflection.Metadata.Decoding.SignatureDecoder`1" />. It may be null.
            </param>
            <param name="handle">
            The type specification handle.
            </param>
            <param name="code">
            When <see cref="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes"/> is used indicates whether
            the type reference is to class or value type. Otherwise <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Unresolved"/>
            will be passed.
            </param>
        </member>
        <member name="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Unresolved">
            <summary>
            It is not known in the current context if the type reference or definition is a class or value type.
            This will be the case when <see cref="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes"/> is not specified.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Class">
            <summary>
            The type definition or reference refers to a class.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.ValueType">
            <summary>
            The type definition or reference refers to a value type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.IPrimitiveTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.Decoding.PrimitiveTypeCode)">
            <summary>
            Gets the type symbol for a primitive type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.IConstructedTypeProvider`1.GetGenericInstance(`0,System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.Decoding.ArrayShape)">
            <summary>
            Gets the type symbol for a generalized array of the given element type and shape. 
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.IConstructedTypeProvider`1.GetByReferenceType(`0)">
            <summary>
            Gets the type symbol for a managed pointer to the given element type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.IConstructedTypeProvider`1.GetPointerType(`0)">
            <summary>
            Gets the type symbol for an unmanaged pointer to the given element ty
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Decoding.SignatureDecoder`1">
            <summary>
            Decodes signature blobs.
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.#ctor(System.Reflection.Metadata.Decoding.ISignatureTypeProvider{`0},System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Decoding.SignatureDecoderOptions)">
            <summary>
            Creates a new SignatureDecoder.
            </summary>
            <param name="provider">The provider used to obtain type symbols as the signature is decoded.</param>
            <param name="metadataReader">
            The metadata reader from which the signature was obtained. It may be null if the given provider allows it.
            However, if <see cref="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes"/> is specified, it should
            be non-null to evaluate WinRT projections from class to value type or vice-versa correctly.
            </param>
            <param name="options">Set of optional decoder features to enable.</param>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
            <summary>
            Decodes a type embedded in a signature and advances the reader past the type.
            </summary>
            <param name="blobReader">The blob reader positioned at the leading SignatureTypeCode</param>
            <param name="allowTypeSpecifications">Allow a <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/> to follow a (CLASS | VALUETYPE) in the signature.
            At present, the only context where that would be valid is in a LocalConstantSig as defined by the Portable PDB specification.
            </param>
            <returns>The decoded type.</returns>
            <exception cref="T:System.BadImageFormatException">The reader was not positioned at a valid signature type.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeTypeSequence(System.Reflection.Metadata.BlobReader@)">
            <summary> 
            Decodes a list of types, with at least one instance that is preceded by its count as a compressed integer.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Decodes a method (definition, reference, or standalone) or property signature blob.
            </summary>
            <param name="blobReader">BlobReader positioned at a method signature.</param>
            <returns>The decoded method signature.</returns>
            <exception cref="T:System.BadImageFormatException">The method signature is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Decodes a method specification signature blob and advances the reader past the signature.
            </summary>
            <param name="blobReader">A BlobReader positioned at a valid method specification signature.</param>
            <returns>The types used to instantiate a generic method via the method specification.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Decodes a local variable signature blob and advances the reader past the signature.
            </summary>
            <param name="blobReader">The blob reader positioned at a local variable signature.</param>
            <returns>The local variable types.</returns>
            <exception cref="T:System.BadImageFormatException">The local variable signature is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Decoding.SignatureDecoder`1.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Decodes a field signature blob and advances the reader past the signature.
            </summary>
            <param name="blobReader">The blob reader positioned at a field signature.</param>
            <returns>The decoded field type.</returns>
        </member>
        <member name="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.None">
            <summary>
            Disable all options (default when no options are passed).
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Decoding.SignatureDecoderOptions.DifferentiateClassAndValueTypes">
            <summary>
            Causes the decoder to pass <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Class"/> or <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.ValueType"/>
            to the <see cref="T:System.Reflection.Metadata.Decoding.ITypeProvider`1"/> instead of <see cref="F:System.Reflection.Metadata.Decoding.SignatureTypeHandleCode.Unresolved"/>.
            </summary>
            <remarks>
            There is additional overhead for this case when dealing with .winmd files to handle projection.
            Most scenarios will end up resolving valuetype vs. class from the actual definitions and do not
            need to know which was used in the signature. As such, it is not enabled by default.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.Decoding.MethodSignature`1">
            <summary>
            Represents a method (definition, reference, or standalone) or property signature.
            In the case of properties, the signature matches that of a getter with a distinguishing <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.MethodSignature`1.Header">
            <summary>
            Represents the information in the leading byte of the signature (kind, calling convention, flags).
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.MethodSignature`1.ReturnType">
            <summary>
            Gets the method's return type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.MethodSignature`1.RequiredParameterCount">
            <summary>
            Gets the number of parameters that are required. Will be equal to the length <see cref="P:System.Reflection.Metadata.Decoding.MethodSignature`1.ParameterTypes"/> of
            unless this signature represents the standalone call site of a vararg method, in which case the entries
            extra entries in <see cref="P:System.Reflection.Metadata.Decoding.MethodSignature`1.ParameterTypes"/> are the types used for the optional parameters.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.MethodSignature`1.GenericParameterCount">
            <summary>
            Gets the number of generic type parameters of the method. Will be 0 for non-generic methods.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Decoding.MethodSignature`1.ParameterTypes">
            <summary>
            Gets the method's parameter types.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Decoding.PrimitiveTypeCode">
            <summary>
            Represents a primitive type found in metadata signatures.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StandaloneDebugMetadataSerializer.SerializeStandalonePdbStream(System.Reflection.BlobBuilder)">
            <summary>
            Serialized #Pdb stream.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SerializeStringHeap">
            <summary>
            Fills in stringIndexMap with data from stringIndex and write to stringWriter.
            Releases stringIndex as the stringTable is sealed after this point.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder.SuffixSort">
            <summary>
            Sorts strings such that a string is followed immediately by all strings
            that are a suffix of it.  
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
            <summary>
            Table row counts. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
            <summary>
            External table row counts. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.PresentTablesMask">
            <summary>
            Non-empty tables that are emitted into the metadata table stream.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalTablesMask">
            <summary>
            Non-empty tables stored in an external metadata table stream that might be referenced from the metadata table stream being emitted.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
            <summary>
            Exact (unaligned) heap sizes.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.MetadataStreamStorageSize">
            <summary>
            Overall size of metadata stream storage (stream headers, table stream, heaps, additional streams).
            Aligned to <see cref="F:System.Reflection.Metadata.Ecma335.MetadataSizes.StreamAlignment"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.MetadataTableStreamSize">
            <summary>
            The size of metadata stream (#- or #~). Aligned.
            Aligned to <see cref="F:System.Reflection.Metadata.Ecma335.MetadataSizes.StreamAlignment"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataSizes.StandalonePdbStreamSize">
            <summary>
            The size of #Pdb stream. Aligned.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.MetadataHeaderSize">
            <summary>
            Metadata header size.
            Includes:
            - metadata storage signature
            - storage header
            - stream headers
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.MetadataSize">
            <summary>
            Total size of metadata (header and all streams).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
            <summary>
            Provides an extension method to access the TypeDefinitionId column of the ExportedType table.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
            <summary>
            Gets a hint at the likely row number of the target type in the TypeDef table of its module. 
            If the namespaces and names do not match, resolution falls back to a full search of the 
            target TypeDef table. Ignored and should be zero if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder"/> is
            true.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
            <summary>
            Provides extension methods for working with certain raw elements of the Ecma 335 metadata tables and heaps.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the number of rows in the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the size of a row in the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the offset from the start of metadata to the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the size of the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the offset from the start of metadata to the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetMetadataBlock(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the size of the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
            <summary>
            Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
            <summary>
            Returns the a handle to the Blob that follows the given one in the Blob heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
            <summary>
            Returns the a handle to the String that follows the given one in the String heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerates entries of EnC log.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception> 
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerates entries of EnC map.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerate types that define one or more properties. 
            </summary>
            <returns>
            The resulting sequence corresponds exactly to entries in PropertyMap table, 
            i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> is stored in n-th row of PropertyMap.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerate types that define one or more events. 
            </summary>
            <returns>
            The resulting sequence corresponds exactly to entries in EventMap table, 
            i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> is stored in n-th row of EventMap.
            </returns>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
            <summary>
            Maximum number of tables that can be present in Ecma335 metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
            <summary>
            Maximum number of tables that can be present in Ecma335 metadata.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the row number of a metadata table entry that corresponds 
            to the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>One based row number.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="handle"/> is not a valid metadata table handle.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
            <summary>
            Returns the offset of metadata heap data that corresponds 
            to the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>Zero based offset, or -1 if <paramref name="handle"/> isn't a metadata heap handle.</returns>
            <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle"/>.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>Metadata token.</returns>
            <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle"/>.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>Metadata token.</returns>
            <exception cref="T:System.ArgumentException">
            Handle represents a metadata entity that doesn't have a token.
            A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle"/>.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the row number of a metadata table entry that corresponds 
            to the specified <paramref name="handle"/>.
            </summary>
            <returns>
            One based row number, or -1 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)"/>.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
            <summary>
            Returns the offset of metadata heap data that corresponds 
            to the specified <paramref name="handle"/>.
            </summary>
            <returns>
            Zero based offset, or -1 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)"/>.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/>.
            </summary>
            <returns>
            Metadata token, or 0 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            Handle represents a metadata entity that doesn't have a token.
            A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/>.
            </exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/>.
            </summary>
            <returns>
            Metadata token, or 0 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)"/>.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
            <summary>
            Gets the <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex"/> of the table corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind"/>.
            </summary>
            <param name="type">Handle type.</param>
            <param name="index">Table index.</param>
            <returns>True if the handle type corresponds to an Ecma335 table, false otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
            <summary>
            Gets the <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex"/> of the heap corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind"/>.
            </summary>
            <param name="type">Handle type.</param>
            <param name="index">Heap index.</param>
            <returns>True if the handle type corresponds to an Ecma335 heap, false otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
            <summary>
            Creates a handle from a token value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="token"/> is not a valid metadata token.
            It must encode a metadata table entity or an offset in <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/> heap.
            </exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
            <summary>
            Creates an entity handle from a token value.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="token"/> is not a valid metadata entity token.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
            <summary>
            Creates an <see cref="T:System.Reflection.Metadata.EntityHandle"/> from a token value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
            <summary>
            Creates an <see cref="T:System.Reflection.Metadata.EntityHandle"/> from a token value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.EqualsRaw(System.Reflection.Metadata.StringHandle,System.String)">
            <summary>
            Returns true if the given raw (non-virtual) handle represents the same string as given ASCII string.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.IndexOfRaw(System.Int32,System.Char)">
            <summary>
            Returns the heap index of the given ASCII character or -1 if not found prior null terminator or end of heap.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.StartsWithRaw(System.Reflection.Metadata.StringHandle,System.String)">
            <summary>
            Returns true if the given raw (non-virtual) handle represents a string that starts with given ASCII prefix.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.BinarySearchRaw(System.String[],System.Reflection.Metadata.StringHandle)">
            <summary>
            Equivalent to Array.BinarySearch, searches for given raw (non-virtual) handle in given array of ASCII strings.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.HandleType">
            <summary>
            These contants are all in the byte range and apply to the interpretation of <see cref="P:System.Reflection.Metadata.Handle.VType"/>,
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.HandleType.VirtualBit">
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.HandleType.NonVirtualStringTypeMask">
            <summary>
            In the case of string handles, the two lower bits that (in addition to the 
            virtual bit not included in this mask) encode how to obtain the string value.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.TokenTypeIds.VirtualBit">
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities. 
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.TokenTypeIds.IsEntityOrUserStringToken(System.UInt32)">
            <summary>
            Returns true if the token value can escape the metadata reader.
            We don't allow virtual tokens and heap tokens other than UserString to escape 
            since the token type ids are internal to the reader and not specified by ECMA spec.
            
            Spec (Partition III, 1.9 Metadata tokens):
            Many CIL instructions are followed by a "metadata token". This is a 4-byte value, that specifies a row in a
            metadata table, or a starting byte offset in the User String heap. 
            
            For example, a value of 0x02 specifies the TypeDef table; a value of 0x70 specifies the User
            String heap.The value corresponds to the number assigned to that metadata table (see Partition II for the full
            list of tables) or to 0x70 for the User String heap.The least-significant 3 bytes specify the target row within that
            metadata table, or starting byte offset within the User String heap.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Ecma335.NamespaceCache.CacheIsRealized">
            <summary>
            Returns whether the namespaceTable has been created. If it hasn't, calling a GetXXX method
            on this will probably have a very high amount of overhead.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.GetSimpleName(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Int32)">
             <summary>
             This will return a StringHandle for the simple name of a namespace name at the given segment index.
             If no segment index is passed explicitly or the "segment" index is greater than or equal to the number
             of segments, then the last segment is used. "Segment" in this context refers to part of a namespace
             name between dots.
            
             Example: Given a NamespaceDefinitionHandle to "System.Collections.Generic.Test" called 'handle':
            
               reader.GetString(GetSimpleName(handle)) == "Test"
               reader.GetString(GetSimpleName(handle, 0)) == "System"
               reader.GetString(GetSimpleName(handle, 1)) == "Collections"
               reader.GetString(GetSimpleName(handle, 2)) == "Generic"
               reader.GetString(GetSimpleName(handle, 3)) == "Test"
               reader.GetString(GetSimpleName(handle, 1000)) == "Test"
             </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateNamespaceTable">
            <summary>
            Two distinct namespace handles represent the same namespace if their full names are the same. This
            method merges builders corresponding to such namespace handles.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.MergeDuplicateNamespaces(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            This will take 'table' and merge all of the NamespaceData instances that point to the same
            namespace. It has to create 'stringTable' as an intermediate dictionary, so it will hand it
            back to the caller should the caller want to use it.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.SynthesizeNamespaceData(System.String,System.Reflection.Metadata.NamespaceDefinitionHandle)">
            <summary>
            Creates a NamespaceDataBuilder instance that contains a synthesized NamespaceDefinitionHandle, 
            as well as the name provided.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.LinkChildDataToParentData(System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder)">
            <summary>
            Quick convenience method that handles linking together child + parent
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.LinkChildToParentNamespace(System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder,System.Collections.Generic.List{System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            Links a child to its parent namespace. If the parent namespace doesn't exist, this will create a
            virtual one. This will automatically link any virtual namespaces it creates up to its parents.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.ResolveParentChildRelationships(System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Collections.Generic.List{System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            This will link all parents/children in the given namespaces dictionary up to each other.
            
            In some cases, we need to synthesize namespaces that do not have any type definitions or forwarders
            of their own, but do have child namespaces. These are returned via the virtualNamespaces out
            parameter.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateTableWithTypeDefinitions(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder})">
            <summary>
            Loops through all type definitions in metadata, adding them to the given table
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateTableWithExportedTypes(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder})">
            <summary>
            Loops through all type forwarders in metadata, adding them to the given table
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateNamespaceList">
            <summary>
            Populates namespaceList with distinct namespaces. No ordering is guaranteed.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.EnsureNamespaceTableIsPopulated">
            <summary>
            If the namespace table doesn't exist, populates it!
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.EnsureNamespaceListIsPopulated">
            <summary>
            If the namespace list doesn't exist, populates it!
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder">
            <summary>
            An intermediate class used to build NamespaceData instances. This was created because we wanted to
            use ImmutableArrays in NamespaceData, but having ArrayBuilders and ImmutableArrays that served the
            same purpose in NamespaceData got ugly. With the current design of how we create our Namespace
            dictionary, this needs to be a class because we have a many-to-one mapping between NamespaceHandles
            and NamespaceData. So, the pointer semantics must be preserved.
            
            This class assumes that the builders will not be modified in any way after the first call to
            Freeze().
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder.Freeze">
            <summary>
            Returns a NamespaceData that represents this NamespaceDataBuilder instance. After calling
            this method, it is an error to use any methods or fields except Freeze() on the target 
            NamespaceDataBuilder.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.FieldLayoutTableReader.FindFieldLayoutRowId(System.Reflection.Metadata.FieldDefinitionHandle)">
            <summary>
            Returns field offset for given field RowId, or -1 if not available. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.AssemblyRefTableReader.NumberOfNonVirtualRows">
            <summary>
            In CLI metadata equal to the actual number of entries in AssemblyRef table.
            In WinMD metadata it includes synthesized AssemblyRefs in addition.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
            <summary>
            True if the file contains metadata.
            </summary>
            <remarks>
            Corresponds to Flags field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
            <summary>
            File name with extension.
            </summary>
            <remarks>
            Corresponds to Name field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
            <summary>
            Hash value of the file content calculated using <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm"/>.
            </summary>
            <remarks>
            Corresponds to HashValue field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.BlobReader.s_nullCharArray">
            <summary>An array containing the '\0' character.</summary>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
            <summary>
            Reads <see cref="T:System.Decimal"/> number.
            </summary>
            <remarks>
            Decimal number is encoded in 13 bytes as follows:
            - byte 0: highest bit indicates sign (1 for negative, 0 for non-negative); the remaining 7 bits encode scale
            - bytes 1..12: 96-bit unsigned integer in little endian encoding.
            </remarks>
            <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid <see cref="T:System.Decimal"/> number.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
            <summary>
            Reads UTF8 encoded string starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The string.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
            <summary>
            Reads UTF16 (little-endian) encoded string starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The string.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
            <summary>
            Reads bytes starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The byte array.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
            <summary>
            Reads an unsigned compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="value">The value of the compressed integer that was read.</param>
            <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
            <summary>
            Reads an unsigned compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <returns>The value of the compressed integer that was read.</returns>
            <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
            <summary>
            Reads a signed compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="value">The value of the compressed integer that was read.</param>
            <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
            <summary>
            Reads a signed compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <returns>The value of the compressed integer that was read.</returns>
            <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
            <summary>
            Reads type code encoded in a serialized custom attribute value. 
            </summary>
            <returns><see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid"/> if the encoding is invalid.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
            <summary>
            Reads type code encoded in a signature. 
            </summary>
            <returns><see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid"/> if the encoding is invalid.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
            <summary>
            Reads a string encoded as a compressed integer containing its length followed by
            its contents in UTF8. Null strings are encoded as a single 0xFF byte.
            </summary>
            <remarks>Defined as a 'SerString' in the Ecma CLI specification.</remarks>
            <returns>String value or null.</returns>
            <exception cref="T:System.BadImageFormatException">If the encoding is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
            <summary>
            Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).
            </summary>
            <returns>The handle or nil if the encoding is invalid.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
            <summary>
            Reads a #Blob heap handle encoded as a compressed integer.
            </summary>
            <remarks>
            Blobs that contain references to other blobs are used in Portable PDB format, for example <see cref="P:System.Reflection.Metadata.Document.Name"/>.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
            <summary>
            Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.
            </summary>
            <exception cref="T:System.BadImageFormatException">Error while reading from the blob.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="typeCode"/> is not a valid <see cref="T:System.Reflection.Metadata.ConstantTypeCode"/>.</exception>
            <returns>
            Boxed constant value. To avoid allocating the object use Read* methods directly.
            Constants of type <see cref="F:System.Reflection.Metadata.ConstantTypeCode.String"/> are encoded as UTF16 strings, use <see cref="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)"/> to read them.
            </returns>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.TypeCode">
            <summary>
            The type of the constant value.
            </summary>
            <remarks>
            Corresponds to Type field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.Value">
            <summary>
            The constant value.
            </summary>
            <remarks>
            Corresponds to Value field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.Parent">
            <summary>
            The parent handle (<see cref="T:System.Reflection.Metadata.ParameterHandle"/>, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle"/>, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle"/>).
            </summary>
            <remarks>
            Corresponds to Parent field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
            <summary>
            The constructor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle"/>) of the custom attribute type.
            </summary>
            <remarks>
            Corresponds to Type field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
            <summary>
            The handle of the metadata entity the attribute is applied to.
            </summary>
            <remarks>
            Corresponds to Parent field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
            <summary>
            The value of the attribute.
            </summary>
            <remarks>
            Corresponds to Value field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.Decoding.ICustomAttributeTypeProvider{``0})">
            <summary>
            Decodes the arguments encoded in the value blob.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
            <summary>
            Start IL offset of the try block.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
            <summary>
            Length in bytes of try block.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
            <summary>
            Start IL offset of the exception handler.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
            <summary>
            Length in bytes of the exception handler.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
            <summary>
            IL offset of the start of the filter block, or -1 if the region is not a filter.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
            <summary>
            Returns a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, nil token otherwise. 
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Name">
            <summary>
            Name of the target type, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
            <summary>
            Full name of the namespace where the target type, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
            <summary>
            The definition handle of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
            <summary>
            Handle to resolve the implementation of the target type.
            </summary>
            <returns>
            <list type="bullet">
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/> representing another module in the assembly.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/> representing another assembly if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder"/> is true.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.ExportedTypeHandle"/> representing the declaring exported type in which this was is nested.</description></item>
            </list>
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
            <summary>
            Returns field layout offset, or -1 if not available.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
            <summary>
            <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>.
            </summary>
            <remarks>
            Corresponds to Owner field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
            <summary>
            Attributes specifying variance and constraints.
            </summary>
            <remarks>
            Corresponds to Flags field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Index">
            <summary>
            Zero-based index of the parameter within the declaring generic type or method declaration.
            </summary>
            <remarks>
            Corresponds to Number field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Name">
            <summary>
            The name of the generic parameter.
            </summary>
            <remarks>
            Corresponds to Name field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
            <summary>
            The constrained <see cref="T:System.Reflection.Metadata.GenericParameterHandle"/>.
            </summary>
            <remarks>
            Corresponds to Owner field of GenericParamConstraint table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
            <summary>
            Handle (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>) 
            specifying from which type this generic parameter is constrained to derive,
            or which interface this generic parameter is constrained to implement.
            </summary>
            <remarks>
            Corresponds to Constraint field of GenericParamConstraint table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
            <summary>
            Represents generic type parameters of a method or type.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
            <summary>
            Represents constraints of a generic type parameter.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
            <summary>
            Collection of parameters of a specified method.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.MemberReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
            <summary>
            Collection of assembly references.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.ManifestResourceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
            <summary>
            Compares two handles.
            </summary>
            <remarks>
            The order of handles that differ in kind and are not <see cref="T:System.Reflection.Metadata.EntityHandle"/> is undefined.
            Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)"/> returns true.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Compares two entity handles.
            </summary>
            <remarks>
            Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)"/> returns true.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.Handle">
            <summary>
            Represents any metadata entity (type reference/definition/specification, method definition, custom attribute, etc.) or value (string, blob, guid, user string).
            </summary>
            <remarks>
            Use <see cref="T:System.Reflection.Metadata.Handle"/> to store multiple kinds of handles.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.Handle.FromVToken(System.UInt32)">
            <summary>
            Creates <see cref="T:System.Reflection.Metadata.Handle"/> from a token or a token combined with a virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.EntityHandleType">
            <summary>
            Token type (0x##000000), does not include virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.Type">
            <summary>
            Small token type (0x##), does not include virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.EntityHandleValue">
            <summary>
            Value stored in an <see cref="T:System.Reflection.Metadata.EntityHandle"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.SpecificEntityHandleValue">
            <summary>
            Value stored in a concrete entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>, etc.).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.EntityHandle">
            <summary>
            Represents a metadata entity (type reference/definition/specification, method definition, custom attribute, etc.). 
            </summary>
            <remarks>
            Use <see cref="T:System.Reflection.Metadata.EntityHandle"/> to store multiple kinds of entity handles.
            It has smaller memory footprint than <see cref="T:System.Reflection.Metadata.Handle"/>.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.EntityHandle.SpecificHandleValue">
            <summary>
            Value stored in a specific entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>, etc.).
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
            <summary>
            Returns a handle to <see cref="T:System.Reflection.Metadata.MethodDebugInformation"/> corresponding to this handle.
            </summary>
            <remarks>
            The resulting handle is only valid within the context of a <see cref="T:System.Reflection.Metadata.MetadataReader"/> open on the Portable PDB blob,
            which in case of standalone PDB file is a different reader than the one containing this method definition.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.UserStringHandle">
            <summary>
            #UserString heap handle.
            </summary>
            <remarks>
            The handle is 32-bit wide.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
            <summary>
            A handle that represents a namespace definition. 
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
            <summary>
            The interface that is implemented
            <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
            <summary>
            Specifies the byte offset within the referenced file at which this resource record begins.
            </summary>
            <remarks>
            Corresponds to Offset field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
            <summary>
            Resource attributes.
            </summary>
            <remarks>
            Corresponds to Flags field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Name">
            <summary>
            Name of the resource.
            </summary>
            <remarks>
            Corresponds to Name field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
            <summary>
            <see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/>, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/>, or nil handle.
            </summary>
            <remarks>
            Corresponds to Implementation field of ManifestResource table in ECMA-335 Standard.
            
            If nil then <see cref="P:System.Reflection.Metadata.ManifestResource.Offset"/> is an offset in the PE image that contains the metadata, 
            starting from the Resource entry in the CLI header.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.MemberReference.Parent">
            <summary>
            MethodDef, ModuleRef,TypeDef, TypeRef, or TypeSpec handle.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MemberReference.Signature">
            <summary>
            Gets a handle to the signature blob.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
            <summary>
            Determines if the member reference is to a method or field.
            </summary>
            <exception cref="T:System.BadImageFormatException">The member reference signature is invalid.</exception>
        </member>
        <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
            <summary>
            Indicates whether a <see cref="T:System.Reflection.Metadata.StandaloneSignature"/> represents a standalone method or local variable signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
            <summary>
            The <see cref="T:System.Reflection.Metadata.StandaloneSignature"/> represents a standalone method signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
            <summary>
            The <see cref="T:System.Reflection.Metadata.MemberReference"/> references a local variable signature.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MemberReferenceKind">
            <summary>
            Indicates whether a <see cref="T:System.Reflection.Metadata.MemberReference"/> references a method or field.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
            <summary>
            The <see cref="T:System.Reflection.Metadata.MemberReference"/> references a method.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
            <summary>
            The <see cref="T:System.Reflection.Metadata.MemberReference"/> references a field.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
            <summary>
            CLI metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
            <summary>
            Windows Metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
            <summary>
            Windows Metadata generated by managed compilers.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataReader">
            <summary>
            Reads metadata as defined byte the ECMA 335 CLI specification.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)"/> to obtain 
            metadata from a PE image.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)"/> to obtain 
            metadata from a PE image.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReader.IsMinimalDelta">
            <summary>
            True if the metadata stream has minimal delta format. Used for EnC.
            </summary>
            <remarks>
            The metadata stream has minimal delta format if "#JTD" stream is present.
            Minimal delta format uses large size (4B) when encoding table/heap references.
            The heaps in minimal delta only contain data of the delta, 
            there is no padding at the beginning of the heaps that would align them 
            with the original full metadata heaps.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ReadMetadataHeader(System.Reflection.Metadata.BlobReader@,System.String@)">
            <summary>
            Looks like this function reads beginning of the header described in
            Ecma-335 24.2.1 Metadata root
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ReadStreamHeaders(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Reads stream headers described in Ecma-335 24.2.2 Stream header
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReader.TableRowCounts">
            <summary>
            A row count for each possible table. May be indexed by <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
            <summary>
            Information decoded from #Pdb stream, or null if the stream is not present.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.GetNestedTypes(System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Returns an array of types nested in the specified type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.CalculateFieldDefTreatmentAndRowId(System.Reflection.Metadata.FieldDefinitionHandle)">
            <summary>
            The backing field of a WinRT enumeration type is not public although the backing fields
            of managed enumerations are. To allow managed languages to directly access this field,
            it is made public by the metadata adapter.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ImplementsRedirectedInterface(System.Reflection.Metadata.MemberReferenceHandle,System.Boolean@)">
            <summary>
            We want to know if a given method implements a redirected interface.
            For example, if we are given the method RemoveAt on a class "A" 
            which implements the IVector interface (which is redirected
            to IList in .NET) then this method would return true. The most 
            likely reason why we would want to know this is that we wish to hide
            (mark private) all methods which implement methods on a redirected 
            interface.
            </summary>
            <param name="memberRef">The declaration token for the method</param>
            <param name="isIDisposable">
            Returns true if the redirected interface is <see cref="T:System.IDisposable"/>.
            </param>
            <returns>True if the method implements a method on a redirected interface.
            False otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.GetAttributeTypeRaw(System.Reflection.Metadata.CustomAttributeHandle)">
            <summary>
            Returns the type definition or reference handle of the attribute type.
            </summary>
            <returns><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> or nil token if the metadata is invalid and the type can't be determined.</returns>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
            <summary>
            All options are disabled.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
            <summary>
            The options that are used when a <see cref="T:System.Reflection.Metadata.MetadataReader"/> is obtained
            via an overload that does not take a <see cref="T:System.Reflection.Metadata.MetadataReaderOptions"/>
            argument.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
            <summary>
            Windows Runtime projections are enabled (on by default).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataStringComparer">
             <summary>
             Provides string comparison helpers to query strings in metadata while
             avoiding allocation where possible.
             </summary>
            
             <remarks>
             No allocation is performed unless both the handle argument and the
             value argument contain non-ascii text.
            
             Obtain instances using <see cref="P:System.Reflection.Metadata.MetadataReader.StringComparer"/>.
            
             A default-initialized instance is useless and behaves as a null reference.
            
             The code is optimized such that there is no additional overhead in
             re-obtaining a a comparer over hoisting it in to a local.
             
             That is to say that a construct like:
            
             <code>
             if (reader.StringComparer.Equals(typeDef.Namespace, "System") &amp;&amp; 
                 reader.StringComparer.Equals(typeDef.Name, "Object")
             {
                 // found System.Object
             }
             </code>
             
             is no less efficient than:
             
             <code>
             var comparer = reader.StringComparer;
             if (comparer.Equals(typeDef.Namespace, "System") &amp;&amp;
                 comparer.Equals(typeDef.Name, "Object")
             {
                 // found System.Object
             }
             </code>
            
             The choice between them is therefore one of style and not performance.
             </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
             <summary>
             Provides the <see cref="T:System.Reflection.Metadata.MetadataReader"/> with a custom mechanism for decoding
             byte sequences in metadata that represent text.
             </summary>
             <remarks>
             This can be used for the following purposes:
             
             1) To customize the treatment of invalid input. When no decoder is provided,
                the <see cref="T:System.Reflection.Metadata.MetadataReader"/> uses the default fallback replacement 
                with \uFFFD)
            
             2) To reuse existing strings instead of allocating a new one for each decoding
                operation.
             </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
            <summary>
            The default decoder used by <see cref="T:System.Reflection.Metadata.MetadataReader"/> to decode UTF-8 when
            no decoder is provided to the constructor.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
            <summary>
            Creates a <see cref="T:System.Reflection.Metadata.MetadataStringDecoder"/> for the given encoding.
            </summary>
            <param name="encoding">The encoding to use.</param>
            <remarks>
            To cache and reuse existing strings. Create a derived class and override <see cref="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)"/> 
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
            <summary>
            Gets the encoding used by this instance. 
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
            <summary>
            The mechanism through which the <see cref="T:System.Reflection.Metadata.MetadataReader"/> obtains strings
            for byte sequences in metadata. Override this to cache strings if required.
            Otherwise, it is implemented by forwarding straight to <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding"/>
            and every call will allocate a new string.
            </summary>
            <param name="bytes">Pointer to bytes to decode.</param>
            <param name="byteCount">Number of bytes to decode.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
            <summary>
            Size of the method body - includes the header, IL and exception regions.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
            <summary>
            MethodDef or MemberRef handle specifying to which generic method this <see cref="T:System.Reflection.Metadata.MethodSpecification"/> refers,
            that is which generic method is it an instantiation of.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
            <summary>
            Gets a handle to the signature blob.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
            <summary>
            Gets the unqualified name of the NamespaceDefinition.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
            <summary>
            Gets the parent namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
            <summary>
            Gets the namespace definitions that are direct children of the current
            namespace definition. 
            
            System.Collections and System.Linq are direct children of System. 
            System.Collections.Generic is a direct child of System.Collections.
            System.Collections.Generic is *not* a direct child of System.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
            <summary>
            Gets all type definitions that reside directly in a namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
            <summary>
            Gets all exported types that reside directly in a namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Document.Name">
            <summary>
            Returns Document Name Blob.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
            <summary>
            <see cref="T:System.Reflection.Metadata.BlobHandle"/> representing a blob on #Blob heap in Portable PDB 
            structured as Document Name. 
            </summary>
            <remarks>
            The kind of the handle is <see cref="F:System.Reflection.Metadata.HandleKind.Blob"/>. 
            The handle is a specialization of <see cref="T:System.Reflection.Metadata.BlobHandle"/> and doesn't have a distinct kind. 
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
            <summary>
            Returns a handle to <see cref="T:System.Reflection.Metadata.MethodDefinition"/> corresponding to this handle.
            </summary>
            <remarks>
            The resulting handle is only valid within the context of a <see cref="T:System.Reflection.Metadata.MetadataReader"/> open on the type system metadata blob,
            which in case of standalone PDB file is a different reader than the one containing this method debug information.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
            <exception cref="T:System.BadImageFormatException">Invalid blob format.</exception>
        </member>
        <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
            <summary>
            The constant signature.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
            <summary>
            Returns a blob encoding sequence points.
            Use <see cref="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints"/> to decode.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
            <summary>
            The document containing the first sequence point of the method, 
            or nil if the method doesn't have sequence points.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
            <summary>
            Returns local signature handle.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
            <summary>
            If the method is a MoveNext method of a state machine returns the kickoff method of the state machine, otherwise returns nil handle.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
            <summary>
            Returns a body block of a method with specified Relative Virtual Address (RVA);
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="peReader"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException">The body is not found in the metadata or is invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Section where the method is stored is not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
            <summary>
            The attribute argument is a System.Type instance.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
            <summary>
            The attribute argument is "boxed" (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
            <summary>
            The attribute argument is an Enum instance.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureAttributes">
            <summary>
            Specified additional flags that can be applied to method signatures.
            Underlying values correspond to the representation in the leading signature 
            byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
            <summary>
            Generic method.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
            <summary>
            Instance method.
            </summary>
            <remarks>Ecma 335 CLI Specification refers to this flag as HAS_THIS.</remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
            <summary>
            The first explicitly declared parameter represents the instance pointer.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
            <summary>
            Specifies how arguments in a given signature are passed from the caller to the callee.
            Underlying values correspond to the representation in the leading signature byte 
            represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
            <summary>
            Managed calling convention with fixed-length argument list.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
            <summary>
            Unmanaged C/C++-style calling convention where the call stack is cleaned by the caller.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
            <summary>
            Unmanaged calling convention where call stack is cleaned up by the callee.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
            <summary>
            Unmanaged C++-style calling convention for calling instance member functions with a fixed argument list.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
            <summary>
            Unmanaged calling convention where arguments are passed in registers when possible.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
            <summary>
            Managed calling convention for passing extra arguments.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureHeader">
            <summary>
            Represents the signature characteristics specified by the leading byte of signature blobs.
            </summary>
            <remarks>
            This header byte is present in all method definition, method reference, standalone method, field, 
            property, and local variable signatures, but not in type specification signatures.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureKind">
            <summary>
            Specifies the signature kind. Underlying values correspond to the representation 
            in the leading signature byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Method">
            <summary>
            Method reference, method definition, or standalone method signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Field">
            <summary>
            Field signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
            <summary>
            Local variables signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Property">
            <summary>
            Property signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
            <summary>
            Method specification signature.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureTypeCode">
            <summary>
            Represents the type codes that are used in signature encoding.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
            <summary>
            Represents an invalid or uninitialized type code. It will not appear in valid signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
            <summary>
            Represents <see cref="T:System.Void"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
            <summary>
            Represents <see cref="T:System.Boolean"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
            <summary>
            Represents <see cref="T:System.Char"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
            <summary>
            Represents <see cref="T:System.SByte"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
            <summary>
            Represents <see cref="T:System.Byte"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
            <summary>
            Represents <see cref="T:System.Int16"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
            <summary>
            Represents <see cref="T:System.UInt16"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
            <summary>
            Represents <see cref="T:System.Int32"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
            <summary>
            Represents <see cref="T:System.UInt32"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
            <summary>
            Represents <see cref="T:System.Int64"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
            <summary>
            Represents <see cref="T:System.UInt64"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
            <summary>
            Represents <see cref="T:System.Single"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
            <summary>
            Represents <see cref="T:System.Double"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
            <summary>
            Represents <see cref="T:System.String"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
            <summary>
            Represents a unmanaged pointers in signatures.
            It is followed in the blob by the signature encoding of the underlying type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
            <summary>
            Represents managed pointers (byref return values and parameters) in signatures.
            It is followed in the blob by the signature encoding of the underlying type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
            <summary>
            Represents a generic type parameter used within a signature. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
            <summary>
            Represents a generalized <see cref="T:System.Array"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
            <summary>
            Represents the instantiation of a generic type in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
            <summary>
            Represents a System.TypedReference in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
            <summary>
            Represents a <see cref="T:System.IntPtr"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
            <summary>
            Represents a <see cref="T:System.UIntPtr"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
            <summary>
            Represents function pointer types in signatures. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
            <summary>
            Represents <see cref="T:System.Object"/>
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
            <summary>
            Represents a single dimensional <see cref="T:System.Array"/> with 0 lower bound.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
            <summary>
            Represents a generic method parameter used within a signature. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
            <summary>
            Represents a custom modifier applied to a type within a signature that the caller must understand. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
            <summary>
            Represents a custom modifier applied to a type within a signature that the caller can ignore.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
            <summary>
            Precedes a type <see cref="T:System.Reflection.Metadata.EntityHandle"/> in signatures.
            </summary>
            <remarks>
            In raw metadata, this will be encoded as either ELEMENT_TYPE_CLASS (0x12) for reference
            types and ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single
            code because Windows Runtime projections can project from class to value type or vice-versa
            and the raw code is misleading in those cases.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
            <summary>
            Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
            <summary>
            Represents a local variable that is pinned by garbage collector
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
            <summary>
            Gets a handle to the signature blob.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
            <summary>
            Determines the kind of signature, which can be <see cref="F:System.Reflection.Metadata.SignatureKind.Method"/> or <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables"/>
            </summary>
            <exception cref="T:System.BadImageFormatException">The signature is invalid.</exception>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
            <summary>
            Name of the type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
            <summary>
            Full name of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
            <summary>
            The definition handle of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
            <summary>
            The base type of the type definition: either
            <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> or <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
            <summary>
            Returns the enclosing type of a specified nested type or nil handle if the type is not nested.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
            <summary>
            Returns an array of types nested in the specified type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
            <summary>
            Resolution scope in which the target type is defined and is uniquely identified by the specified <see cref="P:System.Reflection.Metadata.TypeReference.Namespace"/> and <see cref="P:System.Reflection.Metadata.TypeReference.Name"/>.
            </summary>
            <remarks>
            Resolution scope can be one of the following handles:
            <list type="bullet">
            <item><description><see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> of the enclosing type, if the target type is a nested type.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.ModuleReferenceHandle"/>, if the target type is defined in another module within the same assembly as this one.</description></item>
            <item><description><see cref="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition"/>, if the target type is defined in the current module. This should not occur in a CLI compressed metadata module.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/>, if the target type is defined in a different assembly from the current module.</description></item>
            <item><description>Nil handle if the target type must be resolved by searching the <see cref="P:System.Reflection.Metadata.MetadataReader.ExportedTypes"/> for a matching <see cref="P:System.Reflection.Metadata.TypeReference.Namespace"/> and <see cref="P:System.Reflection.Metadata.TypeReference.Name"/>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.Name">
            <summary>
            Name of the target type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
            <summary>
            Full name of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.ManagedTextSection">
            <summary>
            Managed .text PE section.
            </summary>
            <remarks>
            Contains in the following order:
            - Import Address Table
            - COR Header
            - IL
            - Metadata
            - Managed Resource Data
            - Strong Name Signature
            - Debug Table
            - Import Table
            - Name Table
            - Runtime Startup Stub
            - Mapped Field Data
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.MetadataSize">
            <summary>
            Total size of metadata (header and all streams).
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.ILStreamSize">
            <summary>
            The size of IL stream (unaligned).
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.MappedFieldDataSize">
            <summary>
            The size of mapped field data stream.
            Aligned to <see cref="F:System.Reflection.PortableExecutable.ManagedTextSection.MappedFieldDataAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.ResourceDataSize">
            <summary>
            The size of managed resource data stream.
            Aligned to <see cref="F:System.Reflection.PortableExecutable.ManagedTextSection.ManagedResourcesDataAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.StrongNameSignatureSize">
            <summary>
            Size of strong name hash.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.RequiresStartupStub">
            <summary>
            If set, the module must include a machine code stub that transfers control to the virtual execution system.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.Requires64bits">
            <summary>
            If set, the module contains instructions that assume a 64 bit instruction set. For example it may depend on an address being 64 bits.
            This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.ManagedTextSection.ImageDebugDirectoryEntrySize">
            <summary>
            The size of a single entry in the "Debug Directory (Image Only)"
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.MinPdbPath">
            <summary>
            Minimal size of PDB path in Debug Directory. We pad the path to this minimal size to
            allow some tools to patch the path without the need to rewrite the entire image.
            This is a workaround put in place until these tools are retired.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.ManagedTextSection.ImageDebugDirectoryBaseSize">
            <summary>
            The size of our debug directory: one entry for debug information, and an optional second one indicating
            that the timestamp is deterministic (i.e. not really a timestamp)
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.ManagedTextSection.Serialize(System.Reflection.BlobBuilder,System.Int32,System.Int32,System.Reflection.PortableExecutable.CorFlags,System.UInt64,System.Reflection.BlobBuilder,System.Reflection.BlobBuilder,System.Reflection.BlobBuilder,System.Reflection.BlobBuilder,System.Reflection.BlobBuilder)">
            <summary>
            Serializes .text section data into a specified <paramref name="builder"/>.
            </summary>
            <param name="builder">An empty builder to serialize section data to.</param>
            <param name="relativeVirtualAddess">Relative virtual address of the section within the containing PE file.</param>
            <param name="entryPointTokenOrRelativeVirtualAddress">Entry point token or RVA (<see cref="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress"/>)</param>
            <param name="corFlags">COR Flags (<see cref="P:System.Reflection.PortableExecutable.CorHeader.Flags"/>).</param>
            <param name="baseAddress">Base address of the PE image.</param>
            <param name="metadataBuilder"><see cref="T:System.Reflection.BlobBuilder"/> containing metadata. Must be populated with data. Linked into the <paramref name="builder"/> and can't be expanded afterwards.</param>
            <param name="ilBuilder"><see cref="T:System.Reflection.BlobBuilder"/> containing IL stream. Must be populated with data. Linked into the <paramref name="builder"/> and can't be expanded afterwards.</param>
            <param name="mappedFieldDataBuilder"><see cref="T:System.Reflection.BlobBuilder"/> containing mapped field data. Must be populated with data. Linked into the <paramref name="builder"/> and can't be expanded afterwards.</param>
            <param name="resourceBuilder"><see cref="T:System.Reflection.BlobBuilder"/> containing managed resource data. Must be populated with data. Linked into the <paramref name="builder"/> and can't be expanded afterwards.</param>
            <param name="debugTableBuilderOpt"><see cref="T:System.Reflection.BlobBuilder"/> containing debug table data. Must be populated with data. Linked into the <paramref name="builder"/> and can't be expanded afterwards.</param>
        </member>
        <member name="M:System.Reflection.PortableExecutable.ManagedTextSection.WriteDebugTableEntry(System.Reflection.BlobBuilder,System.Byte[],System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Write one entry in the "Debug Directory (Image Only)"
            See https://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx
            section 5.1.1 (pages 71-72).
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.ManagedTextSection.WriteDebugTable(System.Reflection.BlobBuilder,System.Reflection.PortableExecutable.PESectionLocation,System.Reflection.PortableExecutable.ContentId,System.Reflection.PortableExecutable.ContentId)">
            <summary>
            Write the entire "Debug Directory (Image Only)" along with data that it points to.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
            <summary>
            The type of target machine.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
            <summary>
            The number of sections. This indicates the size of the section table, which immediately follows the headers.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
            <summary>
            The low 32 bits of the number of seconds since 00:00 January 1, 1970, that indicates when the file was created.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
            <summary>
            The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. 
            This value should be zero for a PE image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
            <summary>
            The number of entries in the symbol table. This data can be used to locate the string table, 
            which immediately follows the symbol table. This value should be zero for a PE image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
            <summary>
            The size of the optional header, which is required for executable files but not for object files. 
            This value should be zero for an object file. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
            <summary>
            The flags that indicate the attributes of the file. 
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.CorFlags">
            <summary>
            COR20Flags
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
            <summary>
            GUID (Globally Unique Identifier) of the associated PDB.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
            <summary>
            Iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
            <summary>
            Path to the .pdb file containing debug information for the PE/COFF file.
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
            <summary>
            Identifies the location, size and format of a block of debug information.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
            <summary>
            The time and date that the debug data was created if the PE/COFF file is not deterministic,
            otherwise a value based on the hash of the content. 
            </summary>
            <remarks>
            The algorithm used to calculate this value is an implementation 
            detail of the tool that produced the file.
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
            <summary>
            The major version number of the debug data format.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
            <summary>
            The minor version number of the debug data format.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
            <summary>
            The format of debugging information. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
            <summary>
            The size of the debug data (not including the debug directory itself).
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
            <summary>
            The address of the debug data when loaded, relative to the image base.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
            <summary>
            The file pointer to the debug data.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
            <summary>
            An unknown value that is ignored by all tools.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
            <summary>
            The COFF debug information (line numbers, symbol table, and string table). 
            This type of debug information is also pointed to by fields in the file headers.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
            <summary>
            Associated PDB file description.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
            <summary>
            Presence of this entry indicates deterministic PE/COFF file.
            </summary>
            <remarks>
            <para>
            The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file 
            is based solely on documented inputs given to the tool (such as source files, resource files, compiler options, etc.) 
            rather than ambient environment variables (such as the current time, the operating system, 
            the bitness of the process running the tool, etc.).
            </para>
            <para>
            The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file 
            does not indicate the date and time when the file was produced and should not be interpreted that way.
            Instead the value of the field is derived from a hash of the file content. The algorithm to calculate 
            this value is an implementation detail of the tool that produced the file.
            </para>
            <para>
            The debug directory entry of type <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible"/> must have all fields, except for Type zeroed.
            </para>
            </remarks>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
            <summary>
            The target CPU is unknown or not specified.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.I386">
            <summary>
            Intel 386.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
            <summary>
            MIPS little-endian WCE v2
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
            <summary>
            Alpha
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
            <summary>
            Hitachi SH3 little endian
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
            <summary>
            Hitachi SH3 DSP.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
            <summary>
            Hitachi SH3 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
            <summary>
            Hitachi SH4 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
            <summary>
            Hitachi SH5.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
            <summary>
            ARM little endian
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
            <summary>
            Thumb.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
            <summary>
            ARM Thumb-2 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
            <summary>
            Matsushita AM33.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
            <summary>
            IBM PowerPC little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
            <summary>
            PowerPCFP
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
            <summary>
            Intel 64
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
            <summary>
            MIPS
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
            <summary>
            ALPHA64
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
            <summary>
            MIPS with FPU.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
            <summary>
            MIPS16 with FPU.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
            <summary>
            Infineon
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
            <summary>
            EFI Byte Code
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
            <summary>
            AMD64 (K8)
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
            <summary>
            M32R little-endian
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEBinaryReader">
             <summary>
             Simple BinaryReader wrapper to:
            
              1) throw BadImageFormat instead of EndOfStream or ArgumentOutOfRange.
              2) limit reads to a subset of the base stream.
            
             Only methods that are needed to read PE headers are implemented.
             </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEBinaryReader.ReadNullPaddedUTF8(System.Int32)">
            <summary>
            Reads a fixed-length byte block as a null-padded UTF8-encoded string.
            The padding is not included in the returned string.
            
            Note that it is legal for UTF8 strings to contain NUL; if NUL occurs
            between non-NUL codepoints, it is not considered to be padding and
            is included in the result.
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEBinaryReader.GetAndValidateSize(System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Resolve image size as either the given user-specified size or distance from current position to end-of-stream.
            Also performs the relevant argument validation and publicly visible caller has same argument names.
            </summary>
            <exception cref="T:System.ArgumentException">size is null and distance from current position to end-of-stream can't fit in Int32.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end-of-stream from current position.</exception>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
            <summary>
            Image can handle a high entropy 64-bit virtual address space.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
            <summary>
            DLL can move.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
            <summary>
            Image is NX compatible.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
            <summary>
            Image understands isolation and doesn't want it.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
            <summary>
            Image does not use SEH.  No SE handler may reside in this image.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
            <summary>
            Do not bind this image.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
            <summary>
            The image must run inside an AppContainer.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
            <summary>
            Driver uses WDM model.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
            <summary>
            Identifies the format of the image file.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
            <summary>
            The linker major version number.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
            <summary>
            The linker minor version number.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
            <summary>
            The size of the code (text) section, or the sum of all code sections if there are multiple sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
            <summary>
            The size of the initialized data section, or the sum of all such sections if there are multiple data sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
            <summary>
            The size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
            <summary>
            The address of the entry point relative to the image base when the PE file is loaded into memory. 
            For program images, this is the starting address. For device drivers, this is the address of the initialization function.
            An entry point is optional for DLLs. When no entry point is present, this field must be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
            <summary>
            The address that is relative to the image base of the beginning-of-code section when it is loaded into memory.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
            <summary>
            The address that is relative to the image base of the beginning-of-data section when it is loaded into memory.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
            <summary>
            The preferred address of the first byte of image when loaded into memory; 
            must be a multiple of 64K.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
            <summary>
            The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>. 
            The default is the page size for the architecture.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
            <summary>
            The alignment factor (in bytes) that is used to align the raw data of sections in the image file. 
            The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. 
            If the <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/> is less than the architecture's page size, 
            then <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/> must match <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
            <summary>
            The major version number of the required operating system.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
            <summary>
            The minor version number of the required operating system.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
            <summary>
            The major version number of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
            <summary>
            The minor version number of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
            <summary>
            The major version number of the subsystem.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
            <summary>
            The minor version number of the subsystem.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
            <summary>
            The size (in bytes) of the image, including all headers, as the image is loaded in memory. 
            It must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
            <summary>
            The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
            <summary>
            The image file checksum. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
            <summary>
            The subsystem that is required to run this image. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
            <summary>
            The size of the stack to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit"/> is committed; 
            the rest is made available one page at a time until the reserve size is reached.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
            <summary>
            The size of the stack to commit.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
            <summary>
            The size of the local heap space to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit"/> is committed; 
            the rest is made available one page at a time until the reserve size is reached.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
            <summary>
            The size of the local heap space to commit.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
            <summary>
            The number of data-directory entries in the remainder of the <see cref="T:System.Reflection.PortableExecutable.PEHeader"/>. Each describes a location and size.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
            <summary>
            The Certificate Table entry points to a table of attribute certificates. 
            These certificates are not loaded into memory as part of the image.
             As such, the first field of this entry, which is normally an RVA, is a file pointer instead.
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEHeaders">
            <summary>
            An object used to read PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
            <summary>
            Reads PE headers from the current location in the stream.
            </summary>
            <param name="peStream">Stream containing PE image starting at the stream's current position and ending at the end of the stream.</param>
            <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
            <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Reads PE headers from the current location in the stream.
            </summary>
            <param name="peStream">Stream containing PE image of the given size starting at its current position.</param>
            <param name="size">Size of the PE image.</param>
            <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
            <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
            <summary>
            Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.
            or -1 if the image does not contain metadata.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
            <summary>
            Gets the size of the CLI metadata 0 if the image does not contain metadata.)
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
            <summary>
            Gets the COFF header of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the PE image to the start of the COFF header.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
            <summary>
            Determines if the image is Coff only.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
            <summary>
            Gets the PE header of the image or null if the image is COFF only.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the image to 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
            <summary>
            Gets the PE section headers.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
            <summary>
            Gets the CLI header or null if the image does not have one.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the image to the COR header or -1 if the image does not have one.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
            <summary>
            Determines if the image represents a Windows console application.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
            <summary>
            Determines if the image represents a dynamically linked library.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
            <summary>
            Determines if the image represents an executable.
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
            <summary>
            Gets the offset (in bytes) from the start of the image to the given directory entry.
            </summary>
            <param name="directory"></param>
            <param name="offset"></param>
            <returns>The section containing the directory could not be found.</returns>
            <exception cref="T:System.BadImageFormatException">The section containing the</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
            <summary>
            Searches sections of the PE image for the one that contains specified Relative Virtual Address.
            </summary>
            <param name="relativeVirtualAddress">Address.</param>
            <returns>
            Index of the section that contains <paramref name="relativeVirtualAddress"/>,
            or -1 if there is none.
            </returns>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEReader">
            <summary>
            Portable Executable format reader.
            </summary>
            <remarks>
            The implementation is thread-safe, that is multiple threads can read data from the reader in parallel.
            Disposal of the reader is not thread-safe (see <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/>).
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in memory.
            </summary>
            <param name="peImage">Pointer to the start of the PE image.</param>
            <param name="size">The size of the PE image.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is <see cref="F:System.IntPtr.Zero"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is negative.</exception>
            <remarks>
            The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a stream.
            </summary>
            <param name="peStream">PE image stream.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> is specified and the PE headers of the image are invalid.
            </exception>
            <remarks>
            Ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> upon successful validation of constructor arguments. It will be 
            disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.
            </summary>
            <param name="peStream">PE image stream.</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified no data 
            is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>. Furthermore, the stream must not be manipulated
            by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is alive and undisposed.
            
            If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/>, the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is also
            specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            after construction.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
            <exception cref="T:System.BadImageFormatException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> is specified and the PE headers of the image are invalid.
            </exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
            <summary>
            Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.
            </summary>
            <param name="peStream">PE image stream.</param>
            <param name="size">PE image size.</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified no data 
            is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>. Furthermore, the stream must not be manipulated
            by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is alive and undisposed.
            
            If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/>, the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is also
            specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            after construction.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a byte array.
            </summary>
            <param name="peImage">PE image.</param>
            <remarks>
            The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
            <summary>
            Disposes all memory allocated by the reader.
            </summary>
            <remarks>
            <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/>  can be called multiple times (but not in parallel).
            It is not safe to call <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/> in parallel with any other operation on the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            or reading from <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock"/>s retrieved from the reader.
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
            <summary>
            Gets the PE headers.
            </summary>
            <exception cref="T:System.BadImageFormatException">The headers contain invalid data.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImageBlock">
            <summary>
            Returns a view of the entire image as a pointer and length.
            </summary>
            <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
            <summary>
            Return true if the reader can access the entire PE image.
            </summary>
            <remarks>
            Returns false if the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is constructed from a stream and only part of it is prefetched into memory.
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
            <summary>
            Gets a pointer to and size of the PE image if available (<see cref="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException">The entire PE image is not available.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
            <summary>
            Returns true if the PE image contains CLI metadata.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
            <summary>
            Loads PE section that contains CLI metadata.
            </summary>
            <exception cref="T:System.InvalidOperationException">The PE image doesn't contain metadata (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata"/> returns false).</exception>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
            <summary>
            Loads PE section that contains the specified <paramref name="relativeVirtualAddress"/> into memory
            and returns a memory block that starts at <paramref name="relativeVirtualAddress"/> and ends at the end of the containing section.
            </summary>
            <param name="relativeVirtualAddress">Relative Virtual Address of the data to read.</param>
            <returns>
            An empty block if <paramref name="relativeVirtualAddress"/> doesn't represent a location in any of the PE sections of this PE image.
            </returns>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
            <summary>
            Reads all Debug Directory table entries.
            </summary>
            <exception cref="T:System.BadImageFormatException">Bad format of the entry.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
            <summary>
            Reads the data pointed to by the specifed Debug Directory entry and interprets them as CodeView.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="entry"/> is not a CodeView entry.</exception>
            <exception cref="T:System.BadImageFormatException">Bad format of the data.</exception>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
            <summary>
            By default the stream is disposed when <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is disposed and sections of the PE image are read lazily.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
            <summary>
            Keep the stream open when the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is disposed.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
            <summary>
            Reads metadata section into memory right away. 
            </summary>
            <remarks>
            Reading from other sections of the file is not allowed (<see cref="T:System.InvalidOperationException"/> is thrown by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>).
            The underlying file may be closed and even deleted after <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is constructed.
            
            <see cref="T:System.Reflection.PortableExecutable.PEReader"/> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified.
            </remarks>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
            <summary>
            Reads the entire image into memory right away. 
            </summary>
            <remarks>
            <see cref="T:System.Reflection.PortableExecutable.PEReader"/> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified.
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
            <summary>
            The name of the section.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
            <summary>
            The total size of the section when loaded into memory. 
            If this value is greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/>, the section is zero-padded. 
            This field is valid only for PE images and should be set to zero for object files.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
            <summary>
            For PE images, the address of the first byte of the section relative to the image base when the 
            section is loaded into memory. For object files, this field is the address of the first byte before
            relocation is applied; for simplicity, compilers should set this to zero. Otherwise, 
            it is an arbitrary value that is subtracted from offsets during relocation.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
            <summary>
            The size of the section (for object files) or the size of the initialized data on disk (for image files).
            For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>.
            If this is less than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/>, the remainder of the section is zero-filled. 
            Because the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/> field is rounded but the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/> field is not, 
            it is possible for <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/> to be greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/> as well.
             When a section contains only uninitialized data, this field should be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
            <summary>
            The file pointer to the first page of the section within the COFF file. 
            For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>. 
            For object files, the value should be aligned on a 4 byte boundary for best performance. 
            When a section contains only uninitialized data, this field should be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
            <summary>
            The file pointer to the beginning of relocation entries for the section.
            This is set to zero for PE images or if there are no relocations.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
            <summary>
            The file pointer to the beginning of line-number entries for the section. 
            This is set to zero if there are no COFF line numbers. 
            This value should be zero for an image because COFF debugging information is deprecated.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
            <summary>
            The number of relocation entries for the section. This is set to zero for PE images.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
            <summary>
            The number of line-number entries for the section.
             This value should be zero for an image because COFF debugging information is deprecated.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
            <summary>
            The flags that describe the characteristics of the section. 
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
            <summary>
            Used to modify the value of the property.
            CLS-compliant setters are named with set_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
            <summary>
            Used to read the value of the property.
            CLS-compliant getters are named with get_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
            <summary>
            Other method for property (not getter or setter) or event (not adder, remover, or raiser).
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
            <summary>
            Used to add a handler for an event.
            Corresponds to the AddOn flag in the Ecma 335 CLI specification.
            CLS-compliant adders are named with add_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
            <summary>
            Used to remove a handler for an event.
            Corresponds to the RemoveOn flag in the Ecma 335 CLI specification.
            CLS-compliant removers are named with remove_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
            <summary>
            Used to indicate that an event has occurred.
            Corresponds to the Fire flag in the Ecma 335 CLI specification.
            CLS-compliant raisers are named with raise_ prefix.
            </summary>
        </member>
        <member name="T:System.Reflection.DeclarativeSecurityAction">
            <summary>
            Specifies the security actions that can be performed using declarative security.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.None">
            <summary>
            No declarative security action.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
            <summary>
            Check that all callers in the call chain have been granted specified permission,
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
            <summary>
            The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
            <summary>
            Without further checks refuse Demand for the specified permission.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
            <summary>
            Without further checks, refuse Demand for all permissions other than those specified.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
            <summary>
            Check that the immediate caller has been granted the specified permission;
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
            <summary>
            The derived class inheriting the class or overriding a method is required to have been granted the specified permission.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
            <summary>
            The request for the minimum permissions required for code to run. This action can only be used within the scope of the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
            <summary>
            The request for additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly. 
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
            <summary>
            The request that permissions that might be misused will not be granted to the calling code. This action can only be used within the scope of the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.Public">
            <summary>
            The Resource is exported from the Assembly
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.Private">
            <summary>
            The Resource is not exported from the Assembly
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
            <summary>
            Masks just the visibility-related attributes.
            </summary>
        </member>
        <member name="T:System.Reflection.AssemblyHashAlgorithm">
            <summary>
            Specifies all the hash algorithms used for hashing assembly files and for generating the strong name.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
            <summary>
            A mask indicating that there is no hash algorithm. If you specify None for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
            <summary>
            Retrieves the MD5 message-digest algorithm. MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
            <summary>
            Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.PublicKey">
            <summary>
            The assembly reference holds the full (unhashed) public key.
            Not applicable on assembly definition.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.Retargetable">
            <summary>
            The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
            <summary>
            The assembly contains Windows Runtime code.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
            <summary>
            Content type mask. Masked bits correspond to values of <see cref="T:System.Reflection.AssemblyContentType"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
            <summary>
            Specifies that just-in-time (JIT) compiler optimization is disabled for the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
            <summary>
            Specifies that just-in-time (JIT) compiler tracking is enabled for the assembly.
            </summary>
        </member>
    </members>
</doc>
